{"version":3,"file":"bundle.js","mappings":"mBACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFV,EAAyBC,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,M,KCEhD,SAASC,EAAyBC,EAAMC,EAAO,IAElD,IAAKA,EAAKC,KACN,MAAM,IAAIC,MAAM,2DAEfF,EAAKG,MACRH,EAAKG,IAAM,gBAGb,IAAIC,EAAO,GAAEJ,EAAKC,oBAAoBD,EAAKG,MAC3CE,QAAQC,IAAK,wCAAuCF,KAEpDC,QAAQC,IAAI,qCAEZ,IAAIC,EAAgB,GAEpB,IAAK,IAAIC,KAAUT,EAAM,CACrB,GAAIS,EAAOC,SAAS,KAChB,SAEJ,IAAIC,EAAYX,EAAKS,GACrB,IAAIG,EAAaD,EAAS,KACtBE,EAAeF,EAAS,OAE5B,OAAQC,GACJ,IAAK,QACDJ,GAAiBM,EAAYL,GAC7B,IAAK,MAAOxB,EAAKa,KAAUX,OAAO4B,QAAQF,GAGtCL,GAAiBQ,EAAUP,EAAQX,EAAOb,GAE9C,MACJ,IAAK,QACDuB,GAAiBM,EAAYL,GAC7B,IAAK,MAAOxB,EAAKa,KAAUX,OAAO4B,QAAQF,GAC1B,UAAR5B,IACAuB,GAAiBQ,EAAUP,EAAQX,IAG3C,MACJ,IAAK,UACDU,GAAiBM,EAAYL,GAC7B,IAAK,MAAOxB,EAAKa,KAAUX,OAAO4B,QAAQF,GAC1B,UAAR5B,IACAuB,GAAiBQ,EAAUP,EAAQX,IAG3C,MACJ,IAAK,OACDU,GAAiBM,EAAYL,GAC7B,IAAK,MAAOxB,EAAKa,KAAUX,OAAO4B,QAAQF,GAC1B,SAAR5B,IACAuB,GAAiBQ,EAAUP,EAAQX,IAG3C,MACJ,QACIQ,QAAQC,IAAK,4BAA2BK,OAiDxD,IAA0BK,EAAAA,EA9CLT,EA+CjBF,QAAQC,IAAI,sDACZD,QAAQC,IAAI,eAAiBU,GApBjC,SAASH,EAAYI,GAOjB,OAhCJ,SAAsBC,GAClB,IAAKA,EAAQC,KACT,MAAM,IAAIjB,MAAM,yCAKpB,IAAIiB,EAAOD,EAAQC,KAanB,MAAQ,UAASA,KAZND,EAAQE,MAAQ,mBAChBF,EAAQG,MAAS,yBAAwBF,QAuB7CG,CANS,CACZH,KAAMF,EACNG,KAAM,QACNC,KAAME,EAAcN,KAM5B,SAASF,EAAUE,EAAYpB,EAAOb,GAClC,YAAoB,IAATA,EAEC,GAAEiC,IADIjC,EAAIyB,SAAS,MAAS,cAAazB,MAAW,WAAUA,SACtCa,MAE5B,GAAEoB,KAAcpB,MA8D5B,SAAS0B,EAAcN,GACnB,OAAOO,EAAeP,EAAWQ,MAAM,KAAK,I,+CAGhD,IAAID,EAAiB,CACjB,IAAsB,yCACtB,QAAsB,uCACtB,WAAsB,kEACtB,mBAAsB,kDACtB,mBAAsB,qDACtB,cAAsB,8BACtB,UAAsB,0BACtB,OAAsB,gCAEtB,UAA4B,oDAC5B,iBAA4B,oDAC5B,oBAA4B,yCAC5B,yBAA4B,qCAC5B,iBAA4B,0BAC5B,iBAA4B,kCAC5B,mBAA4B,qCAC5B,kBAA4B,6BAC5B,gBAA4B,+B","sources":["webpack://k6-summary-to-promgateway/webpack/bootstrap","webpack://k6-summary-to-promgateway/webpack/runtime/define property getters","webpack://k6-summary-to-promgateway/webpack/runtime/hasOwnProperty shorthand","webpack://k6-summary-to-promgateway/webpack/runtime/make namespace object","webpack://k6-summary-to-promgateway/./src/send-metrics.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// const k6 = require('k6');\n// import http from 'k6/http';\n// const http = require('http');\n\n//\n// Main function should be imported and wrapped with the function handleSummary\n//\nexport function sendMetricsToPromGateway(data, opts = {}) {\n\n    if (!opts.host) {\n        throw new Error(\"Please provide the host for the prometheus push-gateway\")\n    }\n    if (!opts.job) {\n      opts.job = \"k6_tests_job\"\n    }\n\n    let url = `${opts.host}/metrics/job/${opts.job}`;\n    console.log(`Configuring the push-gateway path to ${url}`)\n    \n    console.log(\"Computing test summary metrics...\")\n\n    let metricPayload = '';\n\n    for (let metric in data) {\n        if (metric.includes('{')){\n            continue;\n        }\n        var metricObj = data[metric];\n        let metricType = metricObj['type'];\n        let metricValues = metricObj['values'];\n        let promMetric;\n        switch (metricType) {\n            case 'trend':\n                metricPayload += createGauge(metric);\n                for (const [key, value] of Object.entries(metricValues)) {\n                    // const label = key.includes('p(') ? `{quantile=\"${key}\"}` : `{label=\"${key}\"}`;         \n                    // console.log(`Set metric ${metric} to value ${value}`)\n                    metricPayload += addValues(metric, value, key);\n                }\n                break;\n            case 'gauge':\n                metricPayload += createGauge(metric);\n                for (const [key, value] of Object.entries(metricValues)) {\n                    if (key === 'value') {\n                        metricPayload += addValues(metric, value);\n                    }\n                }\n                break;\n            case 'counter':\n                metricPayload += createGauge(metric);\n                for (const [key, value] of Object.entries(metricValues)) {\n                    if (key === 'count') {\n                        metricPayload += addValues(metric, value);\n                    }\n                }\n                break;\n            case 'rate':\n                metricPayload += createGauge(metric);\n                for (const [key, value] of Object.entries(metricValues)) {\n                    if (key === 'rate') {\n                        metricPayload += addValues(metric, value);\n                    }\n                }\n                break;\n            default:\n                console.log(`Unsupported metric type: ${metricType}.`);\n        }\n    }\n    sendMetrics(url, metricPayload)\n}\n\nfunction createMetric(options){\n    if (!options.name) {\n        throw new Error(\"Metric options doesn't include a name\");\n    } \n    // if (!options.value) {\n    //     throw new Error(\"Metric options doesn't include a value \" + options.name);\n    // } \n    let name = options.name;\n    let type = options.type || \"gauge\";\n    let help = options.help || `This metric is called ${name}`;\n    // let value = options.value;\n\n    // let metric;\n\n    // if (options.label){\n    //     metric = `${name}${options.label} ${value}`\n    // } else {\n    //     metric = `${name} ${value}`\n    // }\n\n    return `# TYPE ${name} ${type}\\n# HELP ${help}\\n`\n    // ${metric}\n    // `\n}\n\nfunction createGauge(metricName){\n    const options = {\n        name: metricName, \n        type: \"gauge\", \n        help: getMetricHelp(metricName),\n        // value: metricValue\n    }   \n    return createMetric(options);\n}\n\nfunction addValues(metricName, value, key){\n    if (typeof key !== `undefined`){\n        const label = key.includes('p(') ? `{quantile=\"${key}\"}` : `{label=\"${key}\"}`;  \n        return `${metricName}${label} ${value}\\n`\n    }\n    return `${metricName} ${value}\\n`\n}\n\nfunction sendMetrics(url, payload){\n    console.log(\"Sending test metrics to the Prometheus Pushgateway\");\n    console.log(\"payload is: \" + payload);\n    // const params = {\n    //     headers: {\n    //       'Content-Type': 'text/plain',\n    //     },\n    //   };\n\n    return payload;\n\n    // var options = {\n    //     host: 'qe-releng-pushgateway.cicd.flux.nyc3.internal.digitalocean.com',\n    //     path: '/metrics/job/k6-test-example-with-http-requests',\n    //     //since we are listening on a custom port, we need to specify it by hand\n    //     // port: '1337',\n    //     //This is what changes the request to a POST request\n    //     method: 'POST',\n    //     headers: {'Content-Type': 'text/plain'}\n\n    // };\n\n    // callback = function(response) {\n    //     var str = ''\n    //     response.on('data', function (chunk) {\n    //       str += chunk;\n    //     });\n      \n    //     response.on('end', function () {\n    //       console.log(str);\n    //     });\n    // }\n\n    // var req = http.request(options, callback);\n    // //This is the data we are posting, it needs to be a string or a buffer\n    // req.write(payload);\n    // req.end();\n\n    // var xhr = new XMLHttpRequest();\n    // xhr.open(\"POST\", url, true);\n    // xhr.setRequestHeader('Content-Type', 'text/plain');\n    // xhr.send(payload);\n    // http.post(url, payload, params)\n\n    // gateway.pushAdd({ jobName: jobName })\n    // .then(({ resp, body }) => {\n    //     console.log(`PushGate Response: ${body}`);\n    //     console.log(`PushGate Response status: ${resp.statusCode}`);\n    // })\n    // .catch(err => {\n    //     console.log(`Error when sending metrics to the pushgateway: ${err}`);\n    // });  \n}\n\n// function createMetric(metricName, metricType, value){\n//     return `# TYPE ${metricName} ${metricType}\n//     ${metricName} ${value}`\n// }\n\nfunction getMetricHelp(metricName){\n    return builtinMetrics[metricName.split('{')[0]]\n}\n\nlet builtinMetrics = {\n    \"vus\":                \"Current number of active virtual users\",\n    \"vus_max\":            \"Max possible number of virtual users\",\n    \"iterations\":         \"The aggregate number of times the VUs in the test have executed\",\n    \"iteration_duration\": \"The time it took to complete one full iteration\",\n    \"dropped_iterations\": \"The number of iterations that could not be started\",\n    \"data_received\":      \"The amount of received data\",\n    \"data_sent\":          \"The amount of data sent\",\n    \"checks\":             \"The rate of successful checks\",\n\n    \"http_reqs\":                \"How many HTTP requests has k6 generated, in total\",\n    \"http_req_blocked\":         \"Time spent blocked  before initiating the request\",\n    \"http_req_connecting\":      \"Time spent establishing TCP connection\",\n    \"http_req_tls_handshaking\": \"Time spent handshaking TLS session\",\n    \"http_req_sending\":         \"Time spent sending data\",\n    \"http_req_waiting\":         \"Time spent waiting for response\",\n    \"http_req_receiving\":       \"Time spent receiving response data\",\n    \"http_req_duration\":        \"Total time for the request\",\n    \"http_req_failed\":          \"The rate of failed requests\",\n}\n\n// module.exports = sendMetricsToPromGateway;"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","sendMetricsToPromGateway","data","opts","host","Error","job","url","console","log","metricPayload","metric","includes","metricObj","metricType","metricValues","createGauge","entries","addValues","payload","metricName","options","name","type","help","createMetric","getMetricHelp","builtinMetrics","split"],"sourceRoot":""}